
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `equiv_check.ys' --

1. Executing Liberty frontend: sky130_fd_sc_hd__tt_025C_1v80.lib
Imported 428 cell types from liberty file.

2. Executing Verilog-2005 frontend: rtl_topmodule.v
Parsing Verilog input from `rtl_topmodule.v' to AST representation.
Generating RTLIL representation for module `\rtl_topmodule'.
Successfully finished Verilog frontend.

3. Executing Verilog-2005 frontend: clk_divider.v
Parsing Verilog input from `clk_divider.v' to AST representation.
Generating RTLIL representation for module `\clk_divider'.
Successfully finished Verilog frontend.

4. Executing Verilog-2005 frontend: barrel_shifter.v
Parsing Verilog input from `barrel_shifter.v' to AST representation.
Generating RTLIL representation for module `\barrel_shifter'.
Successfully finished Verilog frontend.

5. Executing Verilog-2005 frontend: lfsr.v
Parsing Verilog input from `lfsr.v' to AST representation.
Generating RTLIL representation for module `\lfsr'.
Successfully finished Verilog frontend.

6. Executing Verilog-2005 frontend: parity_gen.v
Parsing Verilog input from `parity_gen.v' to AST representation.
Generating RTLIL representation for module `\parity_gen'.
Successfully finished Verilog frontend.

7. Executing HIERARCHY pass (managing design hierarchy).

7.1. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     \lfsr
Used module:     \barrel_shifter
Used module:     \clk_divider
Parameter \WIDTH = 10

7.2. Executing AST frontend in derive mode using pre-parsed AST for module `\lfsr'.
Parameter \WIDTH = 10
Generating RTLIL representation for module `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Parameter \div_value = 4

7.3. Executing AST frontend in derive mode using pre-parsed AST for module `\clk_divider'.
Parameter \div_value = 4
Generating RTLIL representation for module `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.

7.4. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     $paramod\clk_divider\div_value=s32'00000000000000000000000000000100

7.5. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     $paramod\clk_divider\div_value=s32'00000000000000000000000000000100
Removing unused module `\lfsr'.
Removing unused module `\clk_divider'.
Removed 2 unused modules.

8. Executing PREP pass.

8.1. Executing HIERARCHY pass (managing design hierarchy).

8.1.1. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     $paramod\clk_divider\div_value=s32'00000000000000000000000000000100

8.1.2. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     $paramod\clk_divider\div_value=s32'00000000000000000000000000000100
Removed 0 unused modules.

8.2. Executing PROC pass (convert processes to netlists).

8.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

8.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 2 switch rules as full_case in process $proc$clk_divider.v:8$26 in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Removed 1 dead cases from process $proc$barrel_shifter.v:9$13 in module barrel_shifter.
Marked 1 switch rules as full_case in process $proc$barrel_shifter.v:9$13 in module barrel_shifter.
Marked 1 switch rules as full_case in process $proc$lfsr.v:9$24 in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$rtl_topmodule.v:60$6 in module rtl_topmodule.
Marked 3 switch rules as full_case in process $proc$rtl_topmodule.v:48$2 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$rtl_topmodule.v:12$1 in module rtl_topmodule.
Removed a total of 1 dead cases.

8.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 5 redundant assignments.
Promoted 4 assignments to connections.

8.2.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:7$31'.
  Set init value: \count = 4'0000
Found init rule in `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:0$30'.
  Set init value: \clk_out = 1'0

8.2.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \rst in `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:8$26'.
Found async reset \rst in `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$lfsr.v:9$24'.

8.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~7 debug messages>

8.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:7$31'.
Creating decoders for process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:0$30'.
Creating decoders for process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:8$26'.
     1/2: $0\count[3:0]
     2/2: $0\clk_out[0:0]
Creating decoders for process `\barrel_shifter.$proc$barrel_shifter.v:9$13'.
     1/1: $1\data_out[9:0]
Creating decoders for process `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$lfsr.v:9$24'.
     1/1: $0\rnd[9:0]
Creating decoders for process `\rtl_topmodule.$proc$rtl_topmodule.v:60$6'.
     1/1: $0\out[10:0]
Creating decoders for process `\rtl_topmodule.$proc$rtl_topmodule.v:48$2'.
     1/3: $3\out_reg[10:0]
     2/3: $2\out_reg[10:0]
     3/3: $1\out_reg[10:0]
Creating decoders for process `\rtl_topmodule.$proc$rtl_topmodule.v:12$1'.
     1/2: $0\C_reg[8:0]
     2/2: $0\A_reg[9:0]

8.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\barrel_shifter.\data_out' from process `\barrel_shifter.$proc$barrel_shifter.v:9$13'.
No latch inferred for signal `\rtl_topmodule.\out_reg' from process `\rtl_topmodule.$proc$rtl_topmodule.v:48$2'.

8.2.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\clk_out' using process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:8$26'.
  created $adff cell `$procdff$74' with positive edge clock and positive level reset.
Creating register for signal `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\count' using process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:8$26'.
  created $adff cell `$procdff$75' with positive edge clock and positive level reset.
Creating register for signal `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd' using process `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$lfsr.v:9$24'.
  created $adff cell `$procdff$76' with positive edge clock and positive level reset.
Creating register for signal `\rtl_topmodule.\out' using process `\rtl_topmodule.$proc$rtl_topmodule.v:60$6'.
  created $dff cell `$procdff$77' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg' using process `\rtl_topmodule.$proc$rtl_topmodule.v:12$1'.
  created $dff cell `$procdff$78' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg' using process `\rtl_topmodule.$proc$rtl_topmodule.v:12$1'.
  created $dff cell `$procdff$79' with positive edge clock.

8.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

8.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:7$31'.
Removing empty process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:0$30'.
Found and cleaned up 1 empty switch in `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:8$26'.
Removing empty process `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$clk_divider.v:8$26'.
Found and cleaned up 1 empty switch in `\barrel_shifter.$proc$barrel_shifter.v:9$13'.
Removing empty process `barrel_shifter.$proc$barrel_shifter.v:9$13'.
Removing empty process `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$lfsr.v:9$24'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$rtl_topmodule.v:60$6'.
Removing empty process `rtl_topmodule.$proc$rtl_topmodule.v:60$6'.
Found and cleaned up 3 empty switches in `\rtl_topmodule.$proc$rtl_topmodule.v:48$2'.
Removing empty process `rtl_topmodule.$proc$rtl_topmodule.v:48$2'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$rtl_topmodule.v:12$1'.
Removing empty process `rtl_topmodule.$proc$rtl_topmodule.v:12$1'.
Cleaned up 7 empty switches.

8.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module parity_gen.
Optimizing module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module barrel_shifter.
<suppressed ~8 debug messages>
Optimizing module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module rtl_topmodule.

8.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module parity_gen.
Optimizing module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module barrel_shifter.
Optimizing module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module rtl_topmodule.

8.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \rtl_topmodule..
Removed 0 unused cells and 35 unused wires.
<suppressed ~5 debug messages>

8.5. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100...
Checking module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010...
Checking module barrel_shifter...
Checking module parity_gen...
Checking module rtl_topmodule...
Found and reported 0 problems.

8.6. Executing OPT pass (performing simple optimizations).

8.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

8.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

8.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \barrel_shifter..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \parity_gen..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \rtl_topmodule..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$54.
    dead port 1/2 on $mux $procmux$57.
    dead port 1/2 on $mux $procmux$63.
Removed 3 multiplexer ports.
<suppressed ~6 debug messages>

8.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
  Optimizing cells in module \barrel_shifter.
  Optimizing cells in module \parity_gen.
  Optimizing cells in module \rtl_topmodule.
Performed a total of 0 changes.

8.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

8.6.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..
Removed 0 unused cells and 3 unused wires.
<suppressed ~1 debug messages>

8.6.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

8.6.8. Rerunning OPT passes. (Maybe there is more to do..)

8.6.9. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \barrel_shifter..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \parity_gen..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \rtl_topmodule..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~6 debug messages>

8.6.10. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
  Optimizing cells in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
  Optimizing cells in module \barrel_shifter.
  Optimizing cells in module \parity_gen.
  Optimizing cells in module \rtl_topmodule.
Performed a total of 0 changes.

8.6.11. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

8.6.12. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..

8.6.13. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

8.6.14. Finished OPT passes. (There is nothing left to do.)

8.7. Executing WREDUCE pass (reducing word size of cells).
Removed top 2 bits (of 4) from port B of cell $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$eq$clk_divider.v:15$27 ($eq).
Removed top 31 bits (of 32) from port B of cell $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$add$clk_divider.v:19$29 ($add).
Removed top 28 bits (of 32) from port Y of cell $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$add$clk_divider.v:19$29 ($add).
Removed top 28 bits (of 32) from wire $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$add$clk_divider.v:19$29_Y.
Removed top 1 bits (of 3) from port B of cell barrel_shifter.$procmux$43_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell barrel_shifter.$procmux$44_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell barrel_shifter.$procmux$45_CMP0 ($eq).
Removed top 3 bits (of 9) from port B of cell rtl_topmodule.$lt$rtl_topmodule.v:49$3 ($lt).
Removed top 2 bits (of 9) from port B of cell rtl_topmodule.$lt$rtl_topmodule.v:51$4 ($lt).
Removed top 1 bits (of 9) from port B of cell rtl_topmodule.$le$rtl_topmodule.v:53$5 ($le).
Removed top 1 bits (of 11) from mux cell rtl_topmodule.$procmux$51 ($mux).
Removed top 1 bits (of 11) from mux cell rtl_topmodule.$procmux$60 ($mux).
Removed top 1 bits (of 11) from mux cell rtl_topmodule.$procmux$66 ($mux).
Removed top 1 bits (of 11) from wire rtl_topmodule.$2\out_reg[10:0].
Removed top 1 bits (of 11) from wire rtl_topmodule.$3\out_reg[10:0].
Removed top 1 bits (of 11) from wire rtl_topmodule.out_reg.

8.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..
Removed 0 unused cells and 4 unused wires.
<suppressed ~2 debug messages>

8.9. Executing MEMORY_COLLECT pass (generating $mem cells).

8.10. Executing OPT pass (performing simple optimizations).

8.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

8.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

8.10.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..

8.10.4. Finished fast OPT passes.

8.11. Printing statistics.

=== $paramod\clk_divider\div_value=s32'00000000000000000000000000000100 ===

   Number of wires:                  9
   Number of wire bits:             18
   Number of public wires:           4
   Number of public wire bits:       7
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  7
     $add                            1
     $adff                           2
     $eq                             1
     $mux                            2
     $not                            1

=== $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010 ===

   Number of wires:                  4
   Number of wire bits:             22
   Number of public wires:           3
   Number of public wire bits:      12
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $adff                           1
     $xor                            1

=== barrel_shifter ===

   Number of wires:                 11
   Number of wire bits:             31
   Number of public wires:           3
   Number of public wire bits:      23
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  9
     $eq                             7
     $logic_not                      1
     $pmux                           1

=== parity_gen ===

   Number of wires:                  2
   Number of wire bits:             11
   Number of public wires:           2
   Number of public wire bits:      11
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $reduce_xor                     1

=== rtl_topmodule ===

   Number of wires:                 20
   Number of wire bits:            136
   Number of public wires:          12
   Number of public wire bits:      83
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 16
     $dff                            3
     $le                             1
     $lt                             2
     $mux                            6
     $paramod\clk_divider\div_value=s32'00000000000000000000000000000100      1
     $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010      1
     barrel_shifter                  1
     parity_gen                      1

=== design hierarchy ===

   rtl_topmodule                     1
     $paramod\clk_divider\div_value=s32'00000000000000000000000000000100      1
     $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010      1
     barrel_shifter                  1
     parity_gen                      1

   Number of wires:                 46
   Number of wire bits:            218
   Number of public wires:          24
   Number of public wire bits:     136
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 31
     $add                            1
     $adff                           3
     $dff                            3
     $eq                             8
     $le                             1
     $logic_not                      1
     $lt                             2
     $mux                            8
     $not                            1
     $pmux                           1
     $reduce_xor                     1
     $xor                            1

8.12. Executing CHECK pass (checking for obvious problems).
Checking module $paramod\clk_divider\div_value=s32'00000000000000000000000000000100...
Checking module $paramod\lfsr\WIDTH=s32'00000000000000000000000000001010...
Checking module barrel_shifter...
Checking module parity_gen...
Checking module rtl_topmodule...
Found and reported 0 problems.

9. Executing Liberty frontend: sky130_fd_sc_hd__tt_025C_1v80.lib
Imported 428 cell types from liberty file.

10. Executing Verilog-2005 frontend: synth_a_netlist.v
Parsing Verilog input from `synth_a_netlist.v' to AST representation.
Generating RTLIL representation for module `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Generating RTLIL representation for module `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Generating RTLIL representation for module `\barrel_shifter'.
Generating RTLIL representation for module `\parity_gen'.
Generating RTLIL representation for module `\rtl_topmodule'.
Successfully finished Verilog frontend.

11. Executing HIERARCHY pass (managing design hierarchy).

11.1. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100

11.2. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100
Removed 0 unused modules.

12. Executing PREP pass.

12.1. Executing HIERARCHY pass (managing design hierarchy).

12.1.1. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100

12.1.2. Analyzing design hierarchy..
Top module:  \rtl_topmodule
Used module:     \parity_gen
Used module:     \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010
Used module:     \barrel_shifter
Used module:     \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100
Removed 0 unused modules.

12.2. Executing PROC pass (convert processes to netlists).

12.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

12.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:983$130 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:979$129 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:975$128 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:971$127 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:967$126 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:963$125 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:959$124 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:955$123 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:951$122 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:947$121 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:943$120 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:939$119 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:935$118 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:931$117 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:927$116 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:923$115 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:919$114 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:915$113 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:911$112 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:906$111 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:900$110 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:894$109 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:888$108 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:882$107 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:876$106 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:870$105 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:864$104 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:858$103 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:852$102 in module rtl_topmodule.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:151$101 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:147$100 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:143$99 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:139$98 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:135$97 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:131$96 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:127$95 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:123$94 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:119$93 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:115$92 in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:89$89 in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:85$88 in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:81$87 in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:77$86 in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Marked 1 switch rules as full_case in process $proc$synth_a_netlist.v:73$84 in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Removed a total of 0 dead cases.

12.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 43 redundant assignments.
Promoted 2 assignments to connections.

12.2.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:21$91'.
  Set init value: \count = 4'0000
Found init rule in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:19$90'.
  Set init value: \clk_out = 1'0

12.2.5. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:151$101'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:147$100'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:143$99'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:139$98'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:135$97'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:131$96'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:127$95'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:123$94'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:119$93'.
Found async reset \rst in `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:115$92'.
Found async reset \rst in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:89$89'.
Found async reset \rst in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:85$88'.
Found async reset \rst in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:81$87'.
Found async reset \rst in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:77$86'.
Found async reset \rst in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:73$84'.

12.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~30 debug messages>

12.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:983$130'.
     1/1: $0\C_reg[8:8]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:979$129'.
     1/1: $0\C_reg[7:7]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:975$128'.
     1/1: $0\C_reg[6:6]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:971$127'.
     1/1: $0\C_reg[5:5]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:967$126'.
     1/1: $0\C_reg[4:4]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:963$125'.
     1/1: $0\C_reg[3:3]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:959$124'.
     1/1: $0\C_reg[2:2]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:955$123'.
     1/1: $0\C_reg[1:1]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:951$122'.
     1/1: $0\C_reg[0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:947$121'.
     1/1: $0\A_reg[9:9]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:943$120'.
     1/1: $0\A_reg[8:8]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:939$119'.
     1/1: $0\A_reg[7:7]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:935$118'.
     1/1: $0\A_reg[6:6]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:931$117'.
     1/1: $0\A_reg[5:5]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:927$116'.
     1/1: $0\A_reg[4:4]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:923$115'.
     1/1: $0\A_reg[3:3]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:919$114'.
     1/1: $0\A_reg[2:2]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:915$113'.
     1/1: $0\A_reg[1:1]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:911$112'.
     1/1: $0\A_reg[0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:906$111'.
     1/1: $0\out_reg[9][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:900$110'.
     1/1: $0\out_reg[8][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:894$109'.
     1/1: $0\out_reg[7][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:888$108'.
     1/1: $0\out_reg[6][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:882$107'.
     1/1: $0\out_reg[5][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:876$106'.
     1/1: $0\out_reg[4][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:870$105'.
     1/1: $0\out_reg[3][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:864$104'.
     1/1: $0\out_reg[2][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:858$103'.
     1/1: $0\out_reg[1][0:0]
Creating decoders for process `\rtl_topmodule.$proc$synth_a_netlist.v:852$102'.
     1/1: $0\out_reg[0][0:0]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:151$101'.
     1/1: $0\rnd[9:9]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:147$100'.
     1/1: $0\rnd[8:8]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:143$99'.
     1/1: $0\rnd[7:7]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:139$98'.
     1/1: $0\rnd[6:6]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:135$97'.
     1/1: $0\rnd[5:5]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:131$96'.
     1/1: $0\rnd[4:4]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:127$95'.
     1/1: $0\rnd[3:3]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:123$94'.
     1/1: $0\rnd[2:2]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:119$93'.
     1/1: $0\rnd[1:1]
Creating decoders for process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:115$92'.
     1/1: $0\rnd[0:0]
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:21$91'.
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:19$90'.
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:89$89'.
     1/1: $0\count[3:3]
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:85$88'.
     1/1: $0\count[2:2]
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:81$87'.
     1/1: $0\count[1:1]
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:77$86'.
     1/1: $0\count[0:0]
Creating decoders for process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:73$84'.
     1/1: $0\clk_out[0:0]

12.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).

12.2.9. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\rtl_topmodule.\C_reg [8]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:983$130'.
  created $dff cell `$procdff$220' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [7]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:979$129'.
  created $dff cell `$procdff$221' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [6]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:975$128'.
  created $dff cell `$procdff$222' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [5]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:971$127'.
  created $dff cell `$procdff$223' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [4]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:967$126'.
  created $dff cell `$procdff$224' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [3]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:963$125'.
  created $dff cell `$procdff$225' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [2]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:959$124'.
  created $dff cell `$procdff$226' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [1]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:955$123'.
  created $dff cell `$procdff$227' with positive edge clock.
Creating register for signal `\rtl_topmodule.\C_reg [0]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:951$122'.
  created $dff cell `$procdff$228' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [9]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:947$121'.
  created $dff cell `$procdff$229' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [8]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:943$120'.
  created $dff cell `$procdff$230' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [7]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:939$119'.
  created $dff cell `$procdff$231' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [6]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:935$118'.
  created $dff cell `$procdff$232' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [5]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:931$117'.
  created $dff cell `$procdff$233' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [4]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:927$116'.
  created $dff cell `$procdff$234' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [3]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:923$115'.
  created $dff cell `$procdff$235' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [2]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:919$114'.
  created $dff cell `$procdff$236' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [1]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:915$113'.
  created $dff cell `$procdff$237' with positive edge clock.
Creating register for signal `\rtl_topmodule.\A_reg [0]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:911$112'.
  created $dff cell `$procdff$238' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[9]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:906$111'.
  created $dff cell `$procdff$239' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[8]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:900$110'.
  created $dff cell `$procdff$240' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[7]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:894$109'.
  created $dff cell `$procdff$241' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[6]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:888$108'.
  created $dff cell `$procdff$242' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[5]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:882$107'.
  created $dff cell `$procdff$243' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[4]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:876$106'.
  created $dff cell `$procdff$244' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[3]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:870$105'.
  created $dff cell `$procdff$245' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[2]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:864$104'.
  created $dff cell `$procdff$246' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[1]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:858$103'.
  created $dff cell `$procdff$247' with positive edge clock.
Creating register for signal `\rtl_topmodule.\out_reg[0]' using process `\rtl_topmodule.$proc$synth_a_netlist.v:852$102'.
  created $dff cell `$procdff$248' with positive edge clock.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [9]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:151$101'.
  created $adff cell `$procdff$249' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [8]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:147$100'.
  created $adff cell `$procdff$250' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [7]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:143$99'.
  created $adff cell `$procdff$251' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [6]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:139$98'.
  created $adff cell `$procdff$252' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [5]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:135$97'.
  created $adff cell `$procdff$253' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [4]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:131$96'.
  created $adff cell `$procdff$254' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [3]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:127$95'.
  created $adff cell `$procdff$255' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [2]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:123$94'.
  created $adff cell `$procdff$256' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [1]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:119$93'.
  created $adff cell `$procdff$257' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.\rnd [0]' using process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:115$92'.
  created $adff cell `$procdff$258' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\count [3]' using process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:89$89'.
  created $adff cell `$procdff$259' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\count [2]' using process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:85$88'.
  created $adff cell `$procdff$260' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\count [1]' using process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:81$87'.
  created $adff cell `$procdff$261' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\count [0]' using process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:77$86'.
  created $adff cell `$procdff$262' with positive edge clock and positive level reset.
Creating register for signal `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.\clk_out' using process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:73$84'.
  created $adff cell `$procdff$263' with positive edge clock and positive level reset.

12.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

12.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:983$130'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:983$130'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:979$129'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:979$129'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:975$128'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:975$128'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:971$127'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:971$127'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:967$126'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:967$126'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:963$125'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:963$125'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:959$124'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:959$124'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:955$123'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:955$123'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:951$122'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:951$122'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:947$121'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:947$121'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:943$120'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:943$120'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:939$119'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:939$119'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:935$118'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:935$118'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:931$117'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:931$117'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:927$116'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:927$116'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:923$115'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:923$115'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:919$114'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:919$114'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:915$113'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:915$113'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:911$112'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:911$112'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:906$111'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:906$111'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:900$110'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:900$110'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:894$109'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:894$109'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:888$108'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:888$108'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:882$107'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:882$107'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:876$106'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:876$106'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:870$105'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:870$105'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:864$104'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:864$104'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:858$103'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:858$103'.
Found and cleaned up 1 empty switch in `\rtl_topmodule.$proc$synth_a_netlist.v:852$102'.
Removing empty process `rtl_topmodule.$proc$synth_a_netlist.v:852$102'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:151$101'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:147$100'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:143$99'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:139$98'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:135$97'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:131$96'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:127$95'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:123$94'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:119$93'.
Removing empty process `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.$proc$synth_a_netlist.v:115$92'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:21$91'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:19$90'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:89$89'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:85$88'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:81$87'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:77$86'.
Found and cleaned up 1 empty switch in `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:73$84'.
Removing empty process `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.$proc$synth_a_netlist.v:73$84'.
Cleaned up 30 empty switches.

12.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module rtl_topmodule.
Optimizing module parity_gen.
Optimizing module barrel_shifter.
Optimizing module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
<suppressed ~1 debug messages>

12.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module rtl_topmodule.
Optimizing module parity_gen.
Optimizing module barrel_shifter.
Optimizing module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.

12.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \rtl_topmodule..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Removed 1 unused cells and 77 unused wires.
<suppressed ~4 debug messages>

12.5. Executing CHECK pass (checking for obvious problems).
Checking module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100...
Checking module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010...
Checking module barrel_shifter...
Checking module parity_gen...
Checking module rtl_topmodule...
Found and reported 0 problems.

12.6. Executing OPT pass (performing simple optimizations).

12.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

12.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

12.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \barrel_shifter..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \parity_gen..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module \rtl_topmodule..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~30 debug messages>

12.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
  Optimizing cells in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
  Optimizing cells in module \barrel_shifter.
  Optimizing cells in module \parity_gen.
  Optimizing cells in module \rtl_topmodule.
Performed a total of 0 changes.

12.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

12.6.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..

12.6.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

12.6.8. Finished OPT passes. (There is nothing left to do.)

12.7. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 11) from wire rtl_topmodule._00_.
Removed top 10 bits (of 11) from wire rtl_topmodule.out_reg.

12.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

12.9. Executing MEMORY_COLLECT pass (generating $mem cells).

12.10. Executing OPT pass (performing simple optimizations).

12.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
Optimizing module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
Optimizing module barrel_shifter.
Optimizing module parity_gen.
Optimizing module rtl_topmodule.

12.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\$paramod\clk_divider\div_value=s32'00000000000000000000000000000100'.
Finding identical cells in module `\$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010'.
Finding identical cells in module `\barrel_shifter'.
Finding identical cells in module `\parity_gen'.
Finding identical cells in module `\rtl_topmodule'.
Removed a total of 0 cells.

12.10.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100..
Finding unused cells or wires in module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010..
Finding unused cells or wires in module \barrel_shifter..
Finding unused cells or wires in module \parity_gen..
Finding unused cells or wires in module \rtl_topmodule..

12.10.4. Finished fast OPT passes.

12.11. Printing statistics.

=== \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100 ===

   Number of wires:                 11
   Number of wire bits:             17
   Number of public wires:          10
   Number of public wire bits:      16
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 15
     $adff                           5
     $mux                            1
     sky130_fd_sc_hd__a21boi_0       1
     sky130_fd_sc_hd__clkinv_1       2
     sky130_fd_sc_hd__lpflow_inputiso1p_1      1
     sky130_fd_sc_hd__mux2_1         1
     sky130_fd_sc_hd__nand3_1        1
     sky130_fd_sc_hd__nand3b_1       1
     sky130_fd_sc_hd__xnor2_1        1
     sky130_fd_sc_hd__xor2_1         1

=== \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010 ===

   Number of wires:                  4
   Number of wire bits:             22
   Number of public wires:           4
   Number of public wire bits:      22
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 11
     $adff                          10
     sky130_fd_sc_hd__xor2_1         1

=== barrel_shifter ===

   Number of wires:                 42
   Number of wire bits:             62
   Number of public wires:          42
   Number of public wire bits:      62
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 49
     sky130_fd_sc_hd__a2111oi_0      3
     sky130_fd_sc_hd__a222oi_1       7
     sky130_fd_sc_hd__a22o_1         1
     sky130_fd_sc_hd__a22oi_1       10
     sky130_fd_sc_hd__and3_1         1
     sky130_fd_sc_hd__and3b_1        2
     sky130_fd_sc_hd__and4_1         3
     sky130_fd_sc_hd__and4b_1        6
     sky130_fd_sc_hd__clkinv_1       1
     sky130_fd_sc_hd__nand2_1        5
     sky130_fd_sc_hd__nand3_1        4
     sky130_fd_sc_hd__nand4_1        1
     sky130_fd_sc_hd__nand4b_1       1
     sky130_fd_sc_hd__nor3_1         1
     sky130_fd_sc_hd__nor3b_1        3

=== parity_gen ===

   Number of wires:                  9
   Number of wire bits:             18
   Number of public wires:           9
   Number of public wire bits:      18
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  8
     sky130_fd_sc_hd__xnor2_1        7
     sky130_fd_sc_hd__xnor3_1        1

=== rtl_topmodule ===

   Number of wires:                 73
   Number of wire bits:            144
   Number of public wires:          44
   Number of public wire bits:     115
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 93
     $dff                           29
     $mux                           29
     \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100      1
     \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010      1
     barrel_shifter                  1
     parity_gen                      1
     sky130_fd_sc_hd__a211o_1        1
     sky130_fd_sc_hd__a21oi_1        2
     sky130_fd_sc_hd__a22o_1         9
     sky130_fd_sc_hd__a31oi_1        2
     sky130_fd_sc_hd__a41oi_1        1
     sky130_fd_sc_hd__and2_0         1
     sky130_fd_sc_hd__clkinv_1       2
     sky130_fd_sc_hd__lpflow_inputiso1p_1      1
     sky130_fd_sc_hd__nand2_1        3
     sky130_fd_sc_hd__nand2b_1       1
     sky130_fd_sc_hd__nor2_1         3
     sky130_fd_sc_hd__nor3_1         2
     sky130_fd_sc_hd__nor4bb_1       1
     sky130_fd_sc_hd__o31a_1         1
     sky130_fd_sc_hd__or4_1          1

=== design hierarchy ===

   rtl_topmodule                     1
     \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100      1
     \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010      1
     barrel_shifter                  1
     parity_gen                      1

   Number of wires:                139
   Number of wire bits:            263
   Number of public wires:         109
   Number of public wire bits:     233
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                172
     $adff                          15
     $dff                           29
     $mux                           30
     sky130_fd_sc_hd__a2111oi_0      3
     sky130_fd_sc_hd__a211o_1        1
     sky130_fd_sc_hd__a21boi_0       1
     sky130_fd_sc_hd__a21oi_1        2
     sky130_fd_sc_hd__a222oi_1       7
     sky130_fd_sc_hd__a22o_1        10
     sky130_fd_sc_hd__a22oi_1       10
     sky130_fd_sc_hd__a31oi_1        2
     sky130_fd_sc_hd__a41oi_1        1
     sky130_fd_sc_hd__and2_0         1
     sky130_fd_sc_hd__and3_1         1
     sky130_fd_sc_hd__and3b_1        2
     sky130_fd_sc_hd__and4_1         3
     sky130_fd_sc_hd__and4b_1        6
     sky130_fd_sc_hd__clkinv_1       5
     sky130_fd_sc_hd__lpflow_inputiso1p_1      2
     sky130_fd_sc_hd__mux2_1         1
     sky130_fd_sc_hd__nand2_1        8
     sky130_fd_sc_hd__nand2b_1       1
     sky130_fd_sc_hd__nand3_1        5
     sky130_fd_sc_hd__nand3b_1       1
     sky130_fd_sc_hd__nand4_1        1
     sky130_fd_sc_hd__nand4b_1       1
     sky130_fd_sc_hd__nor2_1         3
     sky130_fd_sc_hd__nor3_1         3
     sky130_fd_sc_hd__nor3b_1        3
     sky130_fd_sc_hd__nor4bb_1       1
     sky130_fd_sc_hd__o31a_1         1
     sky130_fd_sc_hd__or4_1          1
     sky130_fd_sc_hd__xnor2_1        8
     sky130_fd_sc_hd__xnor3_1        1
     sky130_fd_sc_hd__xor2_1         2

12.12. Executing CHECK pass (checking for obvious problems).
Checking module \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100...
Checking module \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010...
Checking module barrel_shifter...
Checking module parity_gen...
Checking module rtl_topmodule...
Found and reported 0 problems.

13. Executing EQUIV_SIMPLE pass.
Proved 0 previously unproven $equiv cells.

14. Executing EQUIV_STATUS pass.
No $equiv cells found in \$paramod\clk_divider\div_value=s32'00000000000000000000000000000100.
No $equiv cells found in \$paramod\lfsr\WIDTH=s32'00000000000000000000000000001010.
No $equiv cells found in barrel_shifter.
No $equiv cells found in parity_gen.
No $equiv cells found in rtl_topmodule.

End of script. Logfile hash: 9f0366d8fc, CPU: user 0.91s system 0.11s, MEM: 37.50 MB peak
Yosys 0.33 (git sha1 2584903a060)
Time spent: 58% 4x read_liberty (0 sec), 14% 2x proc_dff (0 sec), ...
